--- a/src/cmds/tpm_unsealdata.c	2017-01-05 11:44:04.302074030 -0500
+++ b/src/cmds/tpm_unsealdata.c 2017-01-06 12:19:21.472088915 -0500
@@ -1,7 +1,9 @@
 /*
+ * Copyright (C) 2010 Citrix Systems, Inc.
+ *
  * The Initial Developer of the Original Code is International
  * Business Machines Corporation. Portions created by IBM
- * Corporation are Copyright (C) 2009 International Business
+ * Corporation are Copyright (C) 2005, 2006 International Business
  * Machines Corporation. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
@@ -18,6 +20,7 @@
  * along with this program; if not, a copy can be viewed at
  * http://www.opensource.org/licenses/cpl1.0.php.
  */
+#include <openssl/evp.h>
 #include <limits.h>
 #include "tpm_tspi.h"
 #include "tpm_utils.h"
@@ -28,17 +31,19 @@
 	logCmdHelp(aCmd);
 	logCmdOption("-i, --infile FILE",
 		     _
-		     ("Filename containing data to unseal."));
+		     ("Filename containing key to seal. Default is STDIN."));
 	logCmdOption("-o, --outfile FILE",
 		     _
-		     ("Filename to write unsealed data to.  Default is STDOUT."));
-	logCmdOption("-z, --srk-well-known",
-		     _
-		     ("Use 20 bytes of zeros (TSS_WELL_KNOWN_SECRET) as the SRK secret."));
+		     ("Filename to write sealed key to.  Default is STDOUT."));
+	logCmdOption("-z, --well-known", _("Use TSS_WELL_KNOWN_SECRET as the SRK secret."));
+	logCmdOption("-u, --unicode", _("Use TSS UNICODE encoding for the SRK password to comply with applications using TSS popup boxes"));
+
 }
 
 static char in_filename[PATH_MAX] = "", out_filename[PATH_MAX] = "";
-static BOOL srkWellKnown = FALSE;
+static BOOL passUnicode = FALSE;
+static BOOL isWellKnown = FALSE;
+TSS_HCONTEXT hContext = 0;
 
 static int parse(const int aOpt, const char *aArg)
 {
@@ -57,8 +62,12 @@
 			rc = 0;
 		}
 		break;
+	case 'u':
+		passUnicode = TRUE;
+		rc = 0;
+		break;
 	case 'z':
-		srkWellKnown = TRUE;
+		isWellKnown = TRUE;
 		rc = 0;
 		break;
 	default:
@@ -71,37 +80,57 @@
 int main(int argc, char **argv)
 {
 
+	int iRc = -1;
 	struct option opts[] =
 	    { {"infile", required_argument, NULL, 'i'},
-	      {"outfile", required_argument, NULL, 'o'},
-	      {"srk-well-known", no_argument, NULL, 'z'},
+	{"outfile", required_argument, NULL, 'o'},
+	{"unicode", no_argument, NULL, 'u'},
+	{"well-known", no_argument, NULL, 'z'}
 	};
-	FILE *fp;
-	int rc=0, tss_size=0, i;
-	unsigned char* tss_data = NULL;
 
-	if (genericOptHandler(argc, argv, "i:o:z", opts,
+	BIO *bdata=NULL;
+	unsigned char *data;
+	int size;
+
+	initIntlSys();
+
+	if (genericOptHandler(argc, argv, "i:o:uz", opts,
 			      sizeof(opts) / sizeof(struct option), parse,
 			      help) != 0)
-		return rc;
-	
-	rc = tpmUnsealFile(in_filename, &tss_data, &tss_size, srkWellKnown);
+		goto out;
 
-	if (strlen(out_filename) == 0) {
-		for (i=0; i < tss_size; i++)
-			printf("%c", tss_data[i]);
+	if (tpmUnsealFile(in_filename, &data, &size, isWellKnown)) {
+		logError(_("unseal failed\n"));
 		goto out;
-	} else if ((fp = fopen(out_filename, "w")) == NULL) {
-			logError(_("Unable to open output file\n"));
-			goto out;
 	}
 
-	if (fwrite(tss_data, tss_size, 1, fp) != 1) {
-		logError(_("Unable to write output file\n"));
+	/* Create a BIO for the output file */
+	if ((bdata = BIO_new(BIO_s_file())) == NULL) {
+		logError(_("Unable to open output BIO\n"));
 		goto out;
 	}
-	fclose(fp);
+
+	/* Assign the output file to the BIO */
+	if (strlen(out_filename) == 0)
+		BIO_set_fp(bdata, stdout, BIO_NOCLOSE);
+	else if (BIO_write_filename(bdata, out_filename) <= 0) {
+		logError(_("Unable to open output file: %s\n"),
+			 out_filename);
+		goto out;
+	}
+
+	/* Output the unsealed data */
+	BIO_write(bdata, data, size);
+	if (BIO_flush(bdata) != 1) {
+		logError(_("Unable to flush output\n"));
+		goto out;
+	}
+	
+	iRc = 0;
+	logSuccess(argv[0]);
+
 out:
-	free(tss_data);
-	return rc;
+	if (bdata)
+		BIO_free(bdata);
+	return iRc;
 }
